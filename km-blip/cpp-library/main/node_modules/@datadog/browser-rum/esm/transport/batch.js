import { Batch, combine, HttpRequest } from '@datadog/browser-core';
import { LifeCycleEventType } from '../domain/lifeCycle';
import { RumEventCategory } from '../types';
import { RumEventType } from '../typesV2';
export function startRumBatch(configuration, lifeCycle) {
    var batch = makeRumBatch(configuration, lifeCycle);
    lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, function (_a) {
        var rumEvent = _a.rumEvent, serverRumEvent = _a.serverRumEvent;
        if (rumEvent.evt.category === RumEventCategory.VIEW) {
            batch.upsert(serverRumEvent, rumEvent.view.id);
        }
        else {
            batch.add(serverRumEvent);
        }
    });
    lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_V2_COLLECTED, function (_a) {
        var rumEvent = _a.rumEvent, serverRumEvent = _a.serverRumEvent;
        if (rumEvent.type === RumEventType.VIEW) {
            batch.upsert(serverRumEvent, rumEvent.view.id);
        }
        else {
            batch.add(serverRumEvent);
        }
    });
    return {
        stop: function () {
            batch.stop();
        },
    };
}
function makeRumBatch(configuration, lifeCycle) {
    var primaryBatch = createRumBatch(configuration.rumEndpoint, function () {
        return lifeCycle.notify(LifeCycleEventType.BEFORE_UNLOAD);
    });
    var replicaBatch;
    var replica = configuration.replica;
    if (replica !== undefined) {
        replicaBatch = createRumBatch(replica.rumEndpoint);
    }
    function createRumBatch(endpointUrl, unloadCallback) {
        return new Batch(new HttpRequest(endpointUrl, configuration.batchBytesLimit, true), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, unloadCallback);
    }
    function withReplicaApplicationId(message) {
        var applicationIdOverwrite = configuration.isEnabled('v2_format')
            ? { application: { id: replica.applicationId } }
            : { application_id: replica.applicationId };
        return combine(message, applicationIdOverwrite);
    }
    var stopped = false;
    return {
        add: function (message) {
            if (stopped) {
                return;
            }
            primaryBatch.add(message);
            if (replicaBatch) {
                replicaBatch.add(withReplicaApplicationId(message));
            }
        },
        stop: function () {
            stopped = true;
        },
        upsert: function (message, key) {
            if (stopped) {
                return;
            }
            primaryBatch.upsert(message, key);
            if (replicaBatch) {
                replicaBatch.upsert(withReplicaApplicationId(message), key);
            }
        },
    };
}
//# sourceMappingURL=batch.js.map