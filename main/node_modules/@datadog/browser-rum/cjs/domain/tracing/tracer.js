"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var browser_core_1 = require("@datadog/browser-core");
function clearTracingIfCancelled(context) {
    if (context.status === 0) {
        context.traceId = undefined;
        context.spanId = undefined;
    }
}
exports.clearTracingIfCancelled = clearTracingIfCancelled;
function startTracer(configuration) {
    return {
        clearTracingIfCancelled: clearTracingIfCancelled,
        traceFetch: function (context) {
            return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {
                context.init = tslib_1.__assign({}, context.init);
                var headers = [];
                if (context.init.headers instanceof Headers) {
                    context.init.headers.forEach(function (value, key) {
                        headers.push([key, value]);
                    });
                }
                else if (Array.isArray(context.init.headers)) {
                    context.init.headers.forEach(function (header) {
                        headers.push(header);
                    });
                }
                else if (context.init.headers) {
                    Object.keys(context.init.headers).forEach(function (key) {
                        headers.push([key, context.init.headers[key]]);
                    });
                }
                context.init.headers = headers.concat(browser_core_1.objectEntries(tracingHeaders));
            });
        },
        traceXhr: function (context, xhr) {
            return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {
                Object.keys(tracingHeaders).forEach(function (name) {
                    xhr.setRequestHeader(name, tracingHeaders[name]);
                });
            });
        },
    };
}
exports.startTracer = startTracer;
function injectHeadersIfTracingAllowed(configuration, context, inject) {
    if (!isTracingSupported() || !isAllowedUrl(configuration, context.url)) {
        return;
    }
    context.traceId = new TraceIdentifier();
    context.spanId = new TraceIdentifier();
    inject(makeTracingHeaders(context.traceId, context.spanId));
}
function isAllowedUrl(configuration, requestUrl) {
    var requestOrigin = browser_core_1.getOrigin(requestUrl);
    for (var _i = 0, _a = configuration.allowedTracingOrigins; _i < _a.length; _i++) {
        var allowedOrigin = _a[_i];
        if (requestOrigin === allowedOrigin || (allowedOrigin instanceof RegExp && allowedOrigin.test(requestOrigin))) {
            return true;
        }
    }
    return false;
}
function isTracingSupported() {
    return getCrypto() !== undefined;
}
exports.isTracingSupported = isTracingSupported;
function getCrypto() {
    return window.crypto || window.msCrypto;
}
function makeTracingHeaders(traceId, spanId) {
    return {
        'x-datadog-origin': 'rum',
        'x-datadog-parent-id': spanId.toDecimalString(),
        'x-datadog-sampled': '1',
        'x-datadog-sampling-priority': '1',
        'x-datadog-trace-id': traceId.toDecimalString(),
    };
}
/* tslint:disable:no-bitwise */
var TraceIdentifier = /** @class */ (function () {
    function TraceIdentifier() {
        this.buffer = new Uint8Array(8);
        getCrypto().getRandomValues(this.buffer);
        this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit
    }
    TraceIdentifier.prototype.toString = function (radix) {
        var high = this.readInt32(0);
        var low = this.readInt32(4);
        var str = '';
        while (1) {
            var mod = (high % radix) * 4294967296 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low) {
                break;
            }
        }
        return str;
    };
    /**
     * Format used everywhere except the trace intake
     */
    TraceIdentifier.prototype.toDecimalString = function () {
        return this.toString(10);
    };
    TraceIdentifier.prototype.readInt32 = function (offset) {
        return (this.buffer[offset] * 16777216 +
            (this.buffer[offset + 1] << 16) +
            (this.buffer[offset + 2] << 8) +
            this.buffer[offset + 3]);
    };
    return TraceIdentifier;
}());
exports.TraceIdentifier = TraceIdentifier;
/* tslint:enable:no-bitwise */
//# sourceMappingURL=tracer.js.map