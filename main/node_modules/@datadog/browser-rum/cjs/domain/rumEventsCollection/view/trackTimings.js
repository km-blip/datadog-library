"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var browser_core_1 = require("@datadog/browser-core");
var lifeCycle_1 = require("../../lifeCycle");
var trackFirstHidden_1 = require("./trackFirstHidden");
function trackTimings(lifeCycle, callback) {
    var timings;
    function setTimings(newTimings) {
        timings = tslib_1.__assign(tslib_1.__assign({}, timings), newTimings);
        callback(timings);
    }
    var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;
    var stopFCPTracking = trackFirstContentfulPaint(lifeCycle, function (firstContentfulPaint) {
        return setTimings({ firstContentfulPaint: firstContentfulPaint });
    }).stop;
    var stopLCPTracking = trackLargestContentfulPaint(lifeCycle, window, function (largestContentfulPaint) {
        setTimings({
            largestContentfulPaint: largestContentfulPaint,
        });
    }).stop;
    var stopFIDTracking = trackFirstInputDelay(lifeCycle, function (firstInputDelay) {
        setTimings({
            firstInputDelay: firstInputDelay,
        });
    }).stop;
    return {
        stop: function () {
            stopNavigationTracking();
            stopFCPTracking();
            stopLCPTracking();
            stopFIDTracking();
        },
    };
}
exports.trackTimings = trackTimings;
function trackNavigationTimings(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'navigation') {
            callback({
                domComplete: entry.domComplete,
                domContentLoaded: entry.domContentLoadedEventEnd,
                domInteractive: entry.domInteractive,
                loadEventEnd: entry.loadEventEnd,
            });
        }
    }).unsubscribe;
    return { stop: stop };
}
exports.trackNavigationTimings = trackNavigationTimings;
function trackFirstContentfulPaint(lifeCycle, callback) {
    var firstHidden = trackFirstHidden_1.trackFirstHidden();
    var stop = lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'paint' &&
            entry.name === 'first-contentful-paint' &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return { stop: stop };
}
exports.trackFirstContentfulPaint = trackFirstContentfulPaint;
/**
 * Track the largest contentful paint (LCP) occuring during the initial View.  This can yield
 * multiple values, only the most recent one should be used.
 * Documentation: https://web.dev/lcp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts
 */
function trackLargestContentfulPaint(lifeCycle, emitter, callback) {
    var firstHidden = trackFirstHidden_1.trackFirstHidden();
    // Ignore entries that come after the first user interaction.  According to the documentation, the
    // browser should not send largest-contentful-paint entries after a user interact with the page,
    // but the web-vitals reference implementation uses this as a safeguard.
    var firstInteractionTimestamp = Infinity;
    var stopEventListener = browser_core_1.addEventListeners(emitter, [browser_core_1.DOM_EVENT.POINTER_DOWN, browser_core_1.DOM_EVENT.KEY_DOWN], function (event) {
        firstInteractionTimestamp = event.timeStamp;
    }, { capture: true, once: true }).stop;
    var unsubcribeLifeCycle = lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'largest-contentful-paint' &&
            entry.startTime < firstInteractionTimestamp &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return {
        stop: function () {
            stopEventListener();
            unsubcribeLifeCycle();
        },
    };
}
exports.trackLargestContentfulPaint = trackLargestContentfulPaint;
/**
 * Track the first input delay (FID) occuring during the initial View.  This yields at most one
 * value.
 * Documentation: https://web.dev/fid/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts
 */
function trackFirstInputDelay(lifeCycle, callback) {
    var firstHidden = trackFirstHidden_1.trackFirstHidden();
    var stop = lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp) {
            callback(entry.processingStart - entry.startTime);
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
exports.trackFirstInputDelay = trackFirstInputDelay;
//# sourceMappingURL=trackTimings.js.map