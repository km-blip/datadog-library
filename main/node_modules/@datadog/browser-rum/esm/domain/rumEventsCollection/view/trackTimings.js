import { __assign } from "tslib";
import { addEventListeners, DOM_EVENT } from '@datadog/browser-core';
import { LifeCycleEventType } from '../../lifeCycle';
import { trackFirstHidden } from './trackFirstHidden';
export function trackTimings(lifeCycle, callback) {
    var timings;
    function setTimings(newTimings) {
        timings = __assign(__assign({}, timings), newTimings);
        callback(timings);
    }
    var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;
    var stopFCPTracking = trackFirstContentfulPaint(lifeCycle, function (firstContentfulPaint) {
        return setTimings({ firstContentfulPaint: firstContentfulPaint });
    }).stop;
    var stopLCPTracking = trackLargestContentfulPaint(lifeCycle, window, function (largestContentfulPaint) {
        setTimings({
            largestContentfulPaint: largestContentfulPaint,
        });
    }).stop;
    var stopFIDTracking = trackFirstInputDelay(lifeCycle, function (firstInputDelay) {
        setTimings({
            firstInputDelay: firstInputDelay,
        });
    }).stop;
    return {
        stop: function () {
            stopNavigationTracking();
            stopFCPTracking();
            stopLCPTracking();
            stopFIDTracking();
        },
    };
}
export function trackNavigationTimings(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'navigation') {
            callback({
                domComplete: entry.domComplete,
                domContentLoaded: entry.domContentLoadedEventEnd,
                domInteractive: entry.domInteractive,
                loadEventEnd: entry.loadEventEnd,
            });
        }
    }).unsubscribe;
    return { stop: stop };
}
export function trackFirstContentfulPaint(lifeCycle, callback) {
    var firstHidden = trackFirstHidden();
    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'paint' &&
            entry.name === 'first-contentful-paint' &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return { stop: stop };
}
/**
 * Track the largest contentful paint (LCP) occuring during the initial View.  This can yield
 * multiple values, only the most recent one should be used.
 * Documentation: https://web.dev/lcp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts
 */
export function trackLargestContentfulPaint(lifeCycle, emitter, callback) {
    var firstHidden = trackFirstHidden();
    // Ignore entries that come after the first user interaction.  According to the documentation, the
    // browser should not send largest-contentful-paint entries after a user interact with the page,
    // but the web-vitals reference implementation uses this as a safeguard.
    var firstInteractionTimestamp = Infinity;
    var stopEventListener = addEventListeners(emitter, [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN], function (event) {
        firstInteractionTimestamp = event.timeStamp;
    }, { capture: true, once: true }).stop;
    var unsubcribeLifeCycle = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'largest-contentful-paint' &&
            entry.startTime < firstInteractionTimestamp &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return {
        stop: function () {
            stopEventListener();
            unsubcribeLifeCycle();
        },
    };
}
/**
 * Track the first input delay (FID) occuring during the initial View.  This yields at most one
 * value.
 * Documentation: https://web.dev/fid/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts
 */
export function trackFirstInputDelay(lifeCycle, callback) {
    var firstHidden = trackFirstHidden();
    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp) {
            callback(entry.processingStart - entry.startTime);
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
//# sourceMappingURL=trackTimings.js.map