import { __assign } from "tslib";
import { addEventListener, DOM_EVENT, generateUUID, monitor, noop, ONE_MINUTE, throttle } from '@datadog/browser-core';
import { supportPerformanceTimingEvent } from '../../../browser/performanceCollection';
import { LifeCycleEventType } from '../../lifeCycle';
import { trackEventCounts } from '../../trackEventCounts';
import { waitIdlePageActivity } from '../../trackPageActivities';
import { trackTimings } from './trackTimings';
export var ViewLoadingType;
(function (ViewLoadingType) {
    ViewLoadingType["INITIAL_LOAD"] = "initial_load";
    ViewLoadingType["ROUTE_CHANGE"] = "route_change";
})(ViewLoadingType || (ViewLoadingType = {}));
export var THROTTLE_VIEW_UPDATE_PERIOD = 3000;
export var SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE;
export function trackViews(location, lifeCycle) {
    var startOrigin = 0;
    var initialView = newView(lifeCycle, location, ViewLoadingType.INITIAL_LOAD, document.referrer, startOrigin);
    var currentView = initialView;
    var stopTimingsTracking = trackTimings(lifeCycle, function (timings) {
        initialView.updateTimings(timings);
        initialView.scheduleUpdate();
    }).stop;
    trackHistory(onLocationChange);
    trackHash(onLocationChange);
    function onLocationChange() {
        if (currentView.isDifferentView(location)) {
            // Renew view on location changes
            currentView.triggerUpdate();
            currentView.end();
            currentView = newView(lifeCycle, location, ViewLoadingType.ROUTE_CHANGE, currentView.url);
        }
        else {
            currentView.updateLocation(location);
            currentView.triggerUpdate();
        }
    }
    // Renew view on session renewal
    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, function () {
        // do not trigger view update to avoid wrong data
        currentView.end();
        currentView = newView(lifeCycle, location, ViewLoadingType.ROUTE_CHANGE, currentView.url);
    });
    // End the current view on page unload
    lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, function () {
        currentView.triggerUpdate();
        currentView.end();
    });
    // Session keep alive
    var keepAliveInterval = window.setInterval(monitor(function () {
        currentView.triggerUpdate();
    }), SESSION_KEEP_ALIVE_INTERVAL);
    return {
        stop: function () {
            stopTimingsTracking();
            currentView.end();
            clearInterval(keepAliveInterval);
        },
    };
}
function newView(lifeCycle, initialLocation, loadingType, referrer, startTime) {
    if (startTime === void 0) { startTime = performance.now(); }
    // Setup initial values
    var id = generateUUID();
    var eventCounts = {
        errorCount: 0,
        longTaskCount: 0,
        resourceCount: 0,
        userActionCount: 0,
    };
    var timings = {};
    var documentVersion = 0;
    var cumulativeLayoutShift;
    var loadingTime;
    var endTime;
    var location = __assign({}, initialLocation);
    lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, { id: id, startTime: startTime, location: location, referrer: referrer });
    // Update the view every time the measures are changing
    var _a = throttle(monitor(triggerViewUpdate), THROTTLE_VIEW_UPDATE_PERIOD, {
        leading: false,
    }), scheduleViewUpdate = _a.throttled, cancelScheduleViewUpdate = _a.cancel;
    var stopEventCountsTracking = trackEventCounts(lifeCycle, function (newEventCounts) {
        eventCounts = newEventCounts;
        scheduleViewUpdate();
    }).stop;
    var _b = trackLoadingTime(loadingType, function (newLoadingTime) {
        loadingTime = newLoadingTime;
        scheduleViewUpdate();
    }), setActivityLoadingTime = _b.setActivityLoadingTime, setLoadEventEnd = _b.setLoadEventEnd;
    var stopActivityLoadingTimeTracking = trackActivityLoadingTime(lifeCycle, setActivityLoadingTime).stop;
    var stopCLSTracking;
    if (isLayoutShiftSupported()) {
        cumulativeLayoutShift = 0;
        (stopCLSTracking = trackLayoutShift(lifeCycle, function (layoutShift) {
            cumulativeLayoutShift += layoutShift;
            scheduleViewUpdate();
        }).stop);
    }
    else {
        stopCLSTracking = noop;
    }
    // Initial view update
    triggerViewUpdate();
    function triggerViewUpdate() {
        documentVersion += 1;
        lifeCycle.notify(LifeCycleEventType.VIEW_UPDATED, {
            cumulativeLayoutShift: cumulativeLayoutShift,
            documentVersion: documentVersion,
            eventCounts: eventCounts,
            id: id,
            loadingTime: loadingTime,
            loadingType: loadingType,
            location: location,
            referrer: referrer,
            startTime: startTime,
            timings: timings,
            duration: (endTime === undefined ? performance.now() : endTime) - startTime,
        });
    }
    return {
        scheduleUpdate: scheduleViewUpdate,
        end: function () {
            endTime = performance.now();
            stopEventCountsTracking();
            stopActivityLoadingTimeTracking();
            stopCLSTracking();
        },
        isDifferentView: function (otherLocation) {
            return (location.pathname !== otherLocation.pathname ||
                (!isHashAnAnchor(otherLocation.hash) && otherLocation.hash !== location.hash));
        },
        triggerUpdate: function () {
            // cancel any pending view updates execution
            cancelScheduleViewUpdate();
            triggerViewUpdate();
        },
        updateTimings: function (newTimings) {
            timings = newTimings;
            if (newTimings.loadEventEnd !== undefined) {
                setLoadEventEnd(newTimings.loadEventEnd);
            }
        },
        updateLocation: function (newLocation) {
            location = __assign({}, newLocation);
        },
        get url() {
            return location.href;
        },
    };
}
function isHashAnAnchor(hash) {
    var correspondingId = hash.substr(1);
    return !!document.getElementById(correspondingId);
}
function trackHistory(onHistoryChange) {
    var originalPushState = history.pushState;
    history.pushState = monitor(function () {
        originalPushState.apply(this, arguments);
        onHistoryChange();
    });
    var originalReplaceState = history.replaceState;
    history.replaceState = monitor(function () {
        originalReplaceState.apply(this, arguments);
        onHistoryChange();
    });
    addEventListener(window, DOM_EVENT.POP_STATE, onHistoryChange);
}
function trackHash(onHashChange) {
    addEventListener(window, DOM_EVENT.HASH_CHANGE, onHashChange);
}
function trackLoadingTime(loadType, callback) {
    var isWaitingForLoadEventEnd = loadType === ViewLoadingType.INITIAL_LOAD;
    var isWaitingForActivityLoadingTime = true;
    var loadingTimeCandidates = [];
    function invokeCallbackIfAllCandidatesAreReceived() {
        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEventEnd && loadingTimeCandidates.length > 0) {
            callback(Math.max.apply(Math, loadingTimeCandidates));
        }
    }
    return {
        setLoadEventEnd: function (loadEventEnd) {
            if (isWaitingForLoadEventEnd) {
                isWaitingForLoadEventEnd = false;
                loadingTimeCandidates.push(loadEventEnd);
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
        setActivityLoadingTime: function (activityLoadingTime) {
            if (isWaitingForActivityLoadingTime) {
                isWaitingForActivityLoadingTime = false;
                if (activityLoadingTime !== undefined) {
                    loadingTimeCandidates.push(activityLoadingTime);
                }
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
    };
}
function trackActivityLoadingTime(lifeCycle, callback) {
    var startTime = performance.now();
    var stopWaitIdlePageActivity = waitIdlePageActivity(lifeCycle, function (hadActivity, endTime) {
        if (hadActivity) {
            callback(endTime - startTime);
        }
        else {
            callback(undefined);
        }
    }).stop;
    return { stop: stopWaitIdlePageActivity };
}
/**
 * Track layout shifts (LS) occuring during the Views.  This yields multiple values that can be
 * added up to compute the cumulated layout shift (CLS).
 *
 * See isLayoutShiftSupported to check for browser support.
 *
 * Documentation: https://web.dev/cls/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts
 */
function trackLayoutShift(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
            callback(entry.value);
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
/**
 * Check whether `layout-shift` is supported by the browser.
 */
function isLayoutShiftSupported() {
    return supportPerformanceTimingEvent('layout-shift');
}
//# sourceMappingURL=trackViews.js.map